
        <!DOCTYPE html>
        <html lang="en">
          <head>
            <meta charset="UTF-8" />
            <title>Error</title>
            <script type="module">
              const error = {"message":"C:\\dev\\pokemmo-tool\\src\\App.jsx: Unexpected token, expected \"}\" (1278:120)\n\n  1276 |                 value={query}\n  1277 |                 onChange={(e)=> setQuery(e.target.value)}\n> 1278 |                 placeholder={mode==='pokemon' ? 'e.g. Garchomp or 445' : 'e.g. Victory Road, Viridian Forest, Route 10' : 'e.g. Giga Drain, Payback'}\n       |                                                                                                                         ^\n  1279 |                 className=\"input\"\n  1280 |                 style={{ height:44, borderRadius:10, fontSize:16 }}\n  1281 |               />","stack":"    at constructor (C:\\dev\\pokemmo-tool\\node_modules\\@babel\\parser\\lib\\index.js:367:19)\n    at JSXParserMixin.raise (C:\\dev\\pokemmo-tool\\node_modules\\@babel\\parser\\lib\\index.js:6630:19)\n    at JSXParserMixin.unexpected (C:\\dev\\pokemmo-tool\\node_modules\\@babel\\parser\\lib\\index.js:6650:16)\n    at JSXParserMixin.expect (C:\\dev\\pokemmo-tool\\node_modules\\@babel\\parser\\lib\\index.js:6930:12)\n    at JSXParserMixin.jsxParseExpressionContainer (C:\\dev\\pokemmo-tool\\node_modules\\@babel\\parser\\lib\\index.js:4670:10)\n    at JSXParserMixin.jsxParseAttributeValue (C:\\dev\\pokemmo-tool\\node_modules\\@babel\\parser\\lib\\index.js:4637:21)\n    at JSXParserMixin.jsxParseAttribute (C:\\dev\\pokemmo-tool\\node_modules\\@babel\\parser\\lib\\index.js:4686:38)\n    at JSXParserMixin.jsxParseOpeningElementAfterName (C:\\dev\\pokemmo-tool\\node_modules\\@babel\\parser\\lib\\index.js:4700:28)\n    at JSXParserMixin.jsxParseOpeningElementAt (C:\\dev\\pokemmo-tool\\node_modules\\@babel\\parser\\lib\\index.js:4695:17)\n    at JSXParserMixin.jsxParseElementAt (C:\\dev\\pokemmo-tool\\node_modules\\@babel\\parser\\lib\\index.js:4719:33)\n    at JSXParserMixin.jsxParseElementAt (C:\\dev\\pokemmo-tool\\node_modules\\@babel\\parser\\lib\\index.js:4731:32)\n    at JSXParserMixin.jsxParseElement (C:\\dev\\pokemmo-tool\\node_modules\\@babel\\parser\\lib\\index.js:4782:17)\n    at JSXParserMixin.parseExprAtom (C:\\dev\\pokemmo-tool\\node_modules\\@babel\\parser\\lib\\index.js:4792:19)\n    at JSXParserMixin.parseExprSubscripts (C:\\dev\\pokemmo-tool\\node_modules\\@babel\\parser\\lib\\index.js:11081:23)\n    at JSXParserMixin.parseUpdate (C:\\dev\\pokemmo-tool\\node_modules\\@babel\\parser\\lib\\index.js:11066:21)\n    at JSXParserMixin.parseMaybeUnary (C:\\dev\\pokemmo-tool\\node_modules\\@babel\\parser\\lib\\index.js:11046:23)\n    at JSXParserMixin.parseMaybeUnaryOrPrivate (C:\\dev\\pokemmo-tool\\node_modules\\@babel\\parser\\lib\\index.js:10899:61)\n    at JSXParserMixin.parseExprOps (C:\\dev\\pokemmo-tool\\node_modules\\@babel\\parser\\lib\\index.js:10904:23)\n    at JSXParserMixin.parseMaybeConditional (C:\\dev\\pokemmo-tool\\node_modules\\@babel\\parser\\lib\\index.js:10881:23)\n    at JSXParserMixin.parseMaybeAssign (C:\\dev\\pokemmo-tool\\node_modules\\@babel\\parser\\lib\\index.js:10831:21)\n    at C:\\dev\\pokemmo-tool\\node_modules\\@babel\\parser\\lib\\index.js:10800:39\n    at JSXParserMixin.allowInAnd (C:\\dev\\pokemmo-tool\\node_modules\\@babel\\parser\\lib\\index.js:12432:12)\n    at JSXParserMixin.parseMaybeAssignAllowIn (C:\\dev\\pokemmo-tool\\node_modules\\@babel\\parser\\lib\\index.js:10800:17)\n    at JSXParserMixin.parseMaybeAssignAllowInOrVoidPattern (C:\\dev\\pokemmo-tool\\node_modules\\@babel\\parser\\lib\\index.js:12499:17)\n    at JSXParserMixin.parseParenAndDistinguishExpression (C:\\dev\\pokemmo-tool\\node_modules\\@babel\\parser\\lib\\index.js:11679:28)\n    at JSXParserMixin.parseExprAtom (C:\\dev\\pokemmo-tool\\node_modules\\@babel\\parser\\lib\\index.js:11331:23)\n    at JSXParserMixin.parseExprAtom (C:\\dev\\pokemmo-tool\\node_modules\\@babel\\parser\\lib\\index.js:4797:20)\n    at JSXParserMixin.parseExprSubscripts (C:\\dev\\pokemmo-tool\\node_modules\\@babel\\parser\\lib\\index.js:11081:23)\n    at JSXParserMixin.parseUpdate (C:\\dev\\pokemmo-tool\\node_modules\\@babel\\parser\\lib\\index.js:11066:21)\n    at JSXParserMixin.parseMaybeUnary (C:\\dev\\pokemmo-tool\\node_modules\\@babel\\parser\\lib\\index.js:11046:23)\n    at JSXParserMixin.parseMaybeUnaryOrPrivate (C:\\dev\\pokemmo-tool\\node_modules\\@babel\\parser\\lib\\index.js:10899:61)\n    at JSXParserMixin.parseExprOpBaseRightExpr (C:\\dev\\pokemmo-tool\\node_modules\\@babel\\parser\\lib\\index.js:10986:34)\n    at JSXParserMixin.parseExprOpRightExpr (C:\\dev\\pokemmo-tool\\node_modules\\@babel\\parser\\lib\\index.js:10981:21)\n    at JSXParserMixin.parseExprOp (C:\\dev\\pokemmo-tool\\node_modules\\@babel\\parser\\lib\\index.js:10947:27)\n    at JSXParserMixin.parseExprOp (C:\\dev\\pokemmo-tool\\node_modules\\@babel\\parser\\lib\\index.js:10953:21)\n    at JSXParserMixin.parseExprOps (C:\\dev\\pokemmo-tool\\node_modules\\@babel\\parser\\lib\\index.js:10908:17)\n    at JSXParserMixin.parseMaybeConditional (C:\\dev\\pokemmo-tool\\node_modules\\@babel\\parser\\lib\\index.js:10881:23)\n    at JSXParserMixin.parseMaybeAssign (C:\\dev\\pokemmo-tool\\node_modules\\@babel\\parser\\lib\\index.js:10831:21)\n    at JSXParserMixin.parseExpressionBase (C:\\dev\\pokemmo-tool\\node_modules\\@babel\\parser\\lib\\index.js:10784:23)\n    at C:\\dev\\pokemmo-tool\\node_modules\\@babel\\parser\\lib\\index.js:10780:39\n    at JSXParserMixin.allowInAnd (C:\\dev\\pokemmo-tool\\node_modules\\@babel\\parser\\lib\\index.js:12432:12)\n    at JSXParserMixin.parseExpression (C:\\dev\\pokemmo-tool\\node_modules\\@babel\\parser\\lib\\index.js:10780:17)\n    at JSXParserMixin.jsxParseExpressionContainer (C:\\dev\\pokemmo-tool\\node_modules\\@babel\\parser\\lib\\index.js:4665:31)\n    at JSXParserMixin.jsxParseElementAt (C:\\dev\\pokemmo-tool\\node_modules\\@babel\\parser\\lib\\index.js:4744:36)\n    at JSXParserMixin.jsxParseElementAt (C:\\dev\\pokemmo-tool\\node_modules\\@babel\\parser\\lib\\index.js:4731:32)\n    at JSXParserMixin.jsxParseElementAt (C:\\dev\\pokemmo-tool\\node_modules\\@babel\\parser\\lib\\index.js:4731:32)\n    at JSXParserMixin.jsxParseElement (C:\\dev\\pokemmo-tool\\node_modules\\@babel\\parser\\lib\\index.js:4782:17)\n    at JSXParserMixin.parseExprAtom (C:\\dev\\pokemmo-tool\\node_modules\\@babel\\parser\\lib\\index.js:4792:19)\n    at JSXParserMixin.parseExprSubscripts (C:\\dev\\pokemmo-tool\\node_modules\\@babel\\parser\\lib\\index.js:11081:23)\n    at JSXParserMixin.parseUpdate (C:\\dev\\pokemmo-tool\\node_modules\\@babel\\parser\\lib\\index.js:11066:21)","id":"C:/dev/pokemmo-tool/src/App.jsx","frame":"1276|                  value={query}\n1277|                  onChange={(e)=> setQuery(e.target.value)}\n1278|                  placeholder={mode==='pokemon' ? 'e.g. Garchomp or 445' : 'e.g. Victory Road, Viridian Forest, Route 10' : 'e.g. Giga Drain, Payback'}\n   |                                                                                                                          ^\n1279|                  className=\"input\"\n1280|                  style={{ height:44, borderRadius:10, fontSize:16 }}","plugin":"vite:react-babel","pluginCode":"import React, { useEffect, useMemo, useState, useRef } from 'react';\nimport './index.css';\nimport rawDex from './pokedex.json';\nimport movesetData from '../pokemon_moveset_data.json';\nimport VersionBadge from \"./components/VersionBadge.jsx\";\nimport OptionsMenu from './components/OptionsMenu.jsx';\nimport PatchNotesButton, { openPatchNotes } from './components/PatchNotesButton.jsx';\n\nconst LOCATIONS_URL = `${import.meta.env.BASE_URL}data/pokemmo_locations.json`;\nconst AREAS_URL     = `${import.meta.env.BASE_URL}data/areas_index.json`;\nconst TM_URL        = `${import.meta.env.BASE_URL}data/tm_locations.json`;\nconst APP_TITLE = \"3's PokeMMO Tool\";\n\nconst DEBUG_LIVE = true; // set false to silence console logs\n\n/** Optional overrides in .env / .env.production:\n *  VITE_SPRITES_BASE=/sprites/pokeapi/\n *  VITE_SPRITES_EXT=.png\n *  VITE_SHOW_CONFIDENCE=1  // set to 0 to hide confidence\n */\nconst SPRITES_BASE = (import.meta.env.VITE_SPRITES_BASE || `${import.meta.env.BASE_URL}sprites/`).replace(/\\/+$/, '/');\nconst SPRITES_EXT  = import.meta.env.VITE_SPRITES_EXT || '.png';\n\nconst SHOW_CONFIDENCE = (import.meta?.env?.VITE_SHOW_CONFIDENCE ?? '1') === '1';\nfunction formatConfidence(c){\n  if (c == null || isNaN(c)) return null;\n  const num = Number(c);\n  const pct = num \u003c= 1 ? Math.round(num * 100) : Math.round(num);\n  // Bound 0..100\n  return Math.max(0, Math.min(100, pct));\n}\n\nconst TRANSPARENT_PNG =\n  'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR4nGNgYAAAAAMAASsJTYQAAAAASUVORK5CYII=';\n\n/* ---------- small style helpers ---------- */\nconst styles = {\n  segWrap: { display:'inline-flex', border:'1px solid #2f2f2f', background:'#171717', borderRadius:999, padding:4, gap:4 },\n  segBtn(active){ return {\n    appearance:'none', border:0, padding:'8px 14px', borderRadius:999, fontWeight:700, cursor:'pointer',\n    transition:'all .15s ease', background: active?'linear-gradient(180deg,#2f2f2f,#1f1f1f)':'transparent',\n    color: active?'#fff':'#cfcfcf', boxShadow: active?'inset 0 0 0 1px #3a3a3a, 0 4px 18px rgba(0,0,0,.35)':'none'\n  };},\n  card: { padding:16, borderRadius:12, border:'1px solid #262626', background:'#111' },\n  areaCard: { padding:12, borderRadius:12, border:'1px solid #262626', background:'#0f0f0f' },\n  gridCols: { display:'grid', gridTemplateColumns:'repeat(auto-fill, minmax(260px, 1fr))', gap:10 },\n  monRow: { display:'flex', gap:10, alignItems:'center', border:'1px solid #262626', borderRadius:10, padding:'8px 10px', background:'#141414' },\n  viewBtn: {\n    padding:'6px 10px',\n    border:'1px solid var(--accent)',\n    borderRadius:8,\n    background:'var(--accent)',\n    color:'#111',\n    fontWeight:700,\n    cursor:'pointer'\n  }\n};\n\n/* ---------- utils ---------- */\nfunction titleCase(s=''){ return String(s).split(' ').map(w => (w? w[0].toUpperCase()+w.slice(1).toLowerCase():w)).join(' '); }\nfunction normalizeKey(s=''){\n  return String(s).toLowerCase().normalize('NFKD').replace(/[^\\w\\s-]/g,'').replace(/\\s+/g,'-').replace(/-+/g,'-').trim();\n}\nfunction normalizeType(t){ return String(t||'').toLowerCase().trim(); }\nfunction normalizeRegion(r=''){ return String(r||'').toLowerCase().replace(/\\s+/g,'').trim(); }\nconst keyName = (s = \"\") => s.trim().toLowerCase().replace(/\\s+/g, \" \");\n\n/* ---------- pokedex adapter ---------- */\nfunction toLegacyShape(m){\n  const types = Array.isArray(m.types) ? m.types.map(normalizeType) : [];\n  return {\n    id: m.dex,\n    name: m.name,\n    types,\n    sprite: m.sprite ?? null,\n    sprites: m.sprites ?? null,\n    image: m.image ?? null,\n    icon: m.icon ?? null\n  };\n}\nconst DEX_LIST = rawDex.map(toLegacyShape);\nconst DEX_BY_NAME = (() => {\n  const map = new Map();\n  for (const m of DEX_LIST) map.set(normalizeKey(m.name), m);\n  return map;\n})();\nconst getMon = (s) => DEX_BY_NAME.get(normalizeKey(s)) || null;\nconst DEX_BY_ID = (() => {\n  const map = new Map();\n  for (const m of DEX_LIST) map.set(m.id, m);\n  return map;\n})();\nconst getMonByDex = (id) => DEX_BY_ID.get(Number(id)) || null;\n\nfunction normalizeEggGroup(g=''){\n  return String(g).toLowerCase().replace('warer','water').replace('hmanoid','humanoid').trim();\n}\n\nconst MOVE_METHODS = [\n  { key:'start', label:'Start' },\n  { key:'lv', label:'Level' },\n  { key:'tutor', label:'Tutor' },\n  { key:'tmhm', label:'TM/HM' },\n  { key:'egg', label:'Egg' }\n];\n\nconst MOVESETS_BY_ID = (() => {\n  const map = new Map();\n  for (const [key, data] of Object.entries(movesetData || {})) {\n    const m = key.match(/^(\\d+)\\s+([^()]+)\\s*\\(([^)]+)\\)$/);\n    if (!m) continue;\n    const id = Number(m[1]);\n    const eggGroups = m[3].split(',').map(s => normalizeEggGroup(s));\n    const start = Array.isArray(data.start) ? data.start.filter(Boolean) : [];\n    const lv = Array.isArray(data.lv)\n      ? data.lv.map(it => {\n          const [lvl, move] = Object.entries(it)[0] || [];\n          return { level: Number(lvl), move };\n        })\n      : [];\n    const tutor = Array.isArray(data.tutor) ? data.tutor.filter(Boolean) : [];\n    const tmhm = Array.isArray(data['tm/hm']) ? data['tm/hm'].filter(Boolean) : [];\n    const egg = Array.isArray(data.egg) ? data.egg.filter(Boolean) : [];\n    map.set(id, { eggGroups, start, lv, tutor, tmhm, egg });\n  }\n  return map;\n})();\n\n/* ---------- sprite source helpers & component ---------- */\nfunction localSpriteCandidates(mon){\n  const id = String(mon?.id||'').trim();\n  const key = normalizeKey(mon?.name||'');\n  const bases = [SPRITES_BASE, `${import.meta.env.BASE_URL}sprites/`, `${import.meta.env.BASE_URL}sprites/pokeapi/`, `${import.meta.env.BASE_URL}sprites/national/`];\n  const exts = [SPRITES_EXT, '.png', '.gif', '.webp'];\n  const out = [];\n  for (const b of bases){ for (const e of exts){ if (id) out.push(`${b}${id}${e}`); if (key) out.push(`${b}${key}${e}`); } }\n  return [...new Set(out)];\n}\nfunction spriteSources(mon){\n  if (!mon) return [];\n  const arr = [];\n  if (mon.sprite) arr.push(mon.sprite);\n  if (mon.sprites?.front_default) arr.push(mon.sprites.front_default);\n  if (mon.image) arr.push(mon.image);\n  if (mon.icon) arr.push(mon.icon);\n  arr.push(...localSpriteCandidates(mon));\n  // PokeAPI fallbacks\n  arr.push(`https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/${mon.id}.png`);\n  arr.push(`https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/other/official-artwork/${mon.id}.png`);\n  return [...new Set(arr)].filter(Boolean);\n}\nfunction Sprite({ mon, size=42, alt='' }){\n  const srcs = React.useMemo(()=> spriteSources(mon), [mon]);\n  const [idx, setIdx] = useState(0);\n  const src = srcs[idx] || TRANSPARENT_PNG;\n  return (\n    \u003cimg\n      src={src}\n      alt={alt || mon?.name || ''}\n      style={{ width:size, height:size, objectFit:'contain', imageRendering:'pixelated' }}\n      onError={() => {\n        if (idx \u003c srcs.length - 1) setIdx(idx + 1);\n      }}\n    />\n  );\n}\n\n/* ---------- Type colors (Gen 1–5) ---------- */\nconst TYPE_COLORS = {\n  normal:'#A8A77A', fire:'#EE8130', water:'#6390F0', electric:'#F7D02C',\n  grass:'#7AC74C', ice:'#96D9D6', fighting:'#C22E28', poison:'#A33EA1',\n  ground:'#E2BF65', flying:'#A98FF3', psychic:'#F95587', bug:'#A6B91A',\n  rock:'#B6A136', ghost:'#735797', dragon:'#6F35FC', dark:'#705746',\n  steel:'#B7B7CE'\n};\nfunction TypePill({ t, compact=false }){\n  const key = normalizeType(t);\n  if (!key) return null;\n  const bg = TYPE_COLORS[key] || '#555';\n  return (\n    \u003cspan title={titleCase(key)} style={{\n      display:'inline-block', padding:compact?'2px 8px':'4px 10px', fontSize:compact?12:13, lineHeight:1,\n      borderRadius:999, fontWeight:800, color:'#111', background:bg, border:'1px solid #00000022', textShadow:'0 1px 0 #ffffff55'\n    }}>{titleCase(key)}\u003c/span>\n  );\n}\n\nconst EGG_GROUP_COLORS = {\n  monster:'#A8A77A', plant:'#7AC74C', dragon:'#6F35FC', bug:'#A6B91A',\n  flying:'#A98FF3', field:'#E2BF65', fairy:'#F95587', 'water a':'#6390F0',\n  'water b':'#4C7CF0', 'water c':'#1D7BF4', chaos:'#705746', humanoid:'#C22E28',\n  hmanoid:'#C22E28', ditto:'#F7D02C', mineral:'#B7B7CE', 'cannot breed':'#616161',\n  genderless:'#616161'\n};\nfunction EggGroupPill({ group }){\n  const key = normalizeEggGroup(group);\n  if (!key) return null;\n  const bg = EGG_GROUP_COLORS[key] || '#555';\n  return (\n    \u003cspan style={{\n      display:'inline-block', padding:'4px 10px', fontSize:13, lineHeight:1,\n      borderRadius:999, fontWeight:800, color:'#111', background:bg,\n      border:'1px solid #00000022'\n    }}>{titleCase(key)}\u003c/span>\n  );\n}\n\nfunction AbilityPill({ label, name, desc }){\n  if (!name) return null;\n  return (\n    \u003cdiv style={{\n      display:'flex', alignItems:'center', gap:6,\n      padding:'4px 8px',\n      borderRadius:8,\n      background:'var(--surface)',\n      border:'1px solid var(--divider)'\n    }}>\n      \u003cspan className=\"label-muted\" style={{ fontSize:12 }}>{label}\u003c/span>\n      \u003cspan style={{ fontWeight:600, color:'var(--accent)' }} title={desc}>{titleCase(name)}\u003c/span>\n    \u003c/div>\n  );\n}\n/* ---------- Method & Rarity palettes ---------- */\nconst METHOD_COLORS = {\n  grass:'#ECEFF1', 'dark grass':'#B0BEC5', cave:'#7E57C2', water:'#4C7CF0',\n  fishing:'#2BB673','old rod':'#239B63','good rod':'#1E8756','super rod':'#176A44',\n  horde:'#E056FD', rocks:'#616161','rock smash':'#616161', headbutt:'#FF7F50',\n  tree:'#C2A83E','swampy grass':'#16A085','npc interaction':'#8E9AAF', interaction:'#8E9AAF',\n  building:'#5C7AEA', inside:'#5C7AEA', outside:'#43BCCD', special:'#F4B400', lure:'#FFB84D'\n};\nfunction methodKey(m=''){ return String(m).toLowerCase().trim(); }\n\n// Balance methods like \"Lure (Water\" -> \"Lure (Water)\"\nfunction cleanMethodLabel(method=''){\n  let m = String(method || '').trim();\n  // Drop stray trailing ')' (bad source data)\n  m = m.replace(/\\)+$/,'');\n  // Balance parentheses if needed\n  const open = (m.match(/\\(/g) || []).length;\n  const close = (m.match(/\\)/g) || []).length;\n  if (open > close) m = m + ')';\n  // Normalize Horde casing\n  if (/^hordes?\\b/i.test(m)) m = 'Horde';\n  return m;\n}\n\nfunction MethodPill({ method }){\n  if (!method) return null;\n  const label = cleanMethodLabel(method);\n  const m = methodKey(label);\n  const base = m.startsWith('lure') ? 'lure' : (METHOD_COLORS[m] ? m : m.replace(/\\s*\\(.*\\)$/,''));\n  const bg = METHOD_COLORS[base] || '#7f8c8d';\n  return (\n    \u003cspan style={{\n      display:'inline-block', padding:'2px 8px', fontSize:12, borderRadius:999,\n      color:'#111', background:bg, fontWeight:800, border:'1px solid #00000022'\n    }}>\n      {label}\n    \u003c/span>\n  );\n}\n\n/* ---- Rarity palette ---- */\nconst RARITY_COLORS = {\n  'very common':'#8B5A2B','common':'#FFFFFF','uncommon':'#2ECC71','rare':'#E74C3C','very rare':'#F1C40F'\n};\nfunction rarityKey(r=''){ return String(r).toLowerCase().trim(); }\nfunction RarityPill({ rarity }){\n  if (!rarity) return null;\n  const k = rarityKey(rarity);\n  const isPercent = /^\\d+%$/.test(k);\n  const bg = isPercent ? '#13B5A6' : (RARITY_COLORS[k] || '#BDC3C7');\n  const color = '#111';\n  return (\n    \u003cspan style={{\n      display:'inline-block', padding:'2px 8px', fontSize:12, borderRadius:999,\n      color, background:bg, fontWeight:800, border:'1px solid #00000022'\n    }}>\n      {rarity}\n    \u003c/span>\n  );\n}\n\nfunction EvolutionChart({ paths = [], onSelect }){\n  if (!paths.length) return null;\n  return (\n    \u003cdiv style={{ display:'flex', flexDirection:'column', gap:8 }}>\n      {paths.map((path, idx) => (\n        \u003cdiv key={idx} style={{ display:'flex', alignItems:'center', flexWrap:'wrap', gap:8 }}>\n          {path.map((node, i) => (\n            \u003cReact.Fragment key={`${idx}-${node.dex}-${i}`}>\n              \u003cdiv\n                style={{\n                  display:'flex', flexDirection:'column', alignItems:'center', cursor:'pointer',\n                  padding:'6px 8px',\n                  background:'var(--surface)',\n                  border:'1px solid var(--divider)',\n                  borderRadius:8\n                }}\n                onClick={() => onSelect && node.mon && onSelect(node.mon)}\n              >\n                \u003cSprite mon={node.mon} size={56} alt={node.mon?.name} />\n                \u003cdiv style={{ fontWeight:700, color:'var(--accent)', textDecoration:'underline', fontSize:14 }}>\n                  {node.mon?.name}\n                \u003c/div>\n                \u003cdiv className=\"label-muted\" style={{ fontSize:12 }}>\n                  {(node.mon?.types || []).map(t => titleCase(t)).join(' / ')}\n                \u003c/div>\n              \u003c/div>\n              {i \u003c path.length - 1 && (\n                \u003cdiv style={{ display:'flex', flexDirection:'column', alignItems:'center' }}>\n                  \u003cdiv style={{ fontSize:20 }}>→\u003c/div>\n                  \u003cdiv className=\"label-muted\" style={{ fontSize:12 }}>\n                    {formatEvoTrigger(path[i+1].details)}\n                  \u003c/div>\n                \u003c/div>\n              )}\n            \u003c/React.Fragment>\n          ))}\n        \u003c/div>\n      ))}\n    \u003c/div>\n  );\n}\n/* ---------- Defense chart ---------- */\nconst TYPE_CHART = {\n  normal:{ weak:['fighting'], res:[], imm:['ghost'] },\n  fire:{ weak:['water','ground','rock'], res:['fire','grass','ice','bug','steel'], imm:[] },\n  water:{ weak:['electric','grass'], res:['fire','water','ice','steel'], imm:[] },\n  electric:{ weak:['ground'], res:['electric','flying','steel'], imm:[] },\n  grass:{ weak:['fire','ice','poison','flying','bug'], res:['water','electric','grass','ground'], imm:[] },\n  ice:{ weak:['fire','fighting','rock','steel'], res:['ice'], imm:[] },\n  fighting:{ weak:['flying','psychic'], res:['bug','rock','dark'], imm:[] },\n  poison:{ weak:['ground','psychic'], res:['grass','fighting','poison','bug'], imm:[] },\n  ground:{ weak:['water','grass','ice'], res:['poison','rock'], imm:['electric'] },\n  flying:{ weak:['electric','ice','rock'], res:['grass','fighting','bug'], imm:['ground'] },\n  psychic:{ weak:['bug','ghost','dark'], res:['fighting','psychic'], imm:[] },\n  bug:{ weak:['fire','flying','rock'], res:['grass','fighting','ground'], imm:[] },\n  rock:{ weak:['water','grass','fighting','ground','steel'], res:['normal','fire','poison','flying'], imm:[] },\n  ghost:{ weak:['ghost','dark'], res:['poison','bug'], imm:['normal','fighting'] },\n  dragon:{ weak:['ice','dragon'], res:['fire','water','electric','grass'], imm:[] },\n  dark:{ weak:['fighting','bug'], res:['ghost','dark'], imm:['psychic'] },\n  steel:{ weak:['fire','fighting','ground'], res:['normal','grass','ice','flying','psychic','bug','rock','dragon','steel'], imm:['poison'] }\n};\nfunction computeWeakness(types = []){\n  const tlist = (Array.isArray(types) ? types : []).map(normalizeType).filter(Boolean);\n  const mult = {};\n  for (const atk of Object.keys(TYPE_CHART)) mult[atk] = 1;\n  for (const def of tlist){\n    const d = TYPE_CHART[def]; if (!d) continue;\n    d.weak.forEach(t => { mult[t] *= 2; });\n    d.res.forEach(t => { mult[t] *= 0.5; });\n    d.imm.forEach(t => { mult[t] *= 0; });\n  }\n  const asType = (n) => Object.entries(mult).filter(([,m]) => m===n).map(([t]) => titleCase(t));\n  return { x4: asType(4), x2: asType(2), x0_5: asType(0.5), x0_25: asType(0.25), x0: asType(0) };\n}\n\n/* ---------- Loaders ---------- */\nfunction useLocationsDb(){\n  const [index, setIndex] = useState({});\n  useEffect(() => {\n    let alive = true;\n    (async () => {\n      try{\n        const res = await fetch(LOCATIONS_URL, { cache:'no-store' });\n        const json = await res.json();\n        const idx = {};\n        for (const [k,v] of Object.entries(json)) {\n          // Drop any bogus location entries with only dashes for a map name\n          const locations = (v?.locations || []).filter(l => !/^-+$/.test(l.map || \"\"));\n          idx[normalizeKey(k)] = { ...v, locations };\n        }\n        if (alive) setIndex(idx);\n      }catch(e){ console.error('load locations failed', e); }\n    })();\n    return () => { alive = false; };\n  }, []);\n  return index;\n}\n\n/** Cleaning helpers for Areas */\nfunction cleanSpeciesName(name=''){\n  let s = String(name)\n    .replace(/^[\\s*•\\-–—]+/g,'')\n    .replace(/\\)+$/,'')\n    .replace(/\\b(?:and|or)\\b/gi,'')\n    .replace(/\\b(?:hordes?|horde)\\b/gi,'')\n    .replace(/\\s{2,}/g,' ')\n    .trim();\n  return s;\n}\n/** NOTE: now balances missing ')' */\nfunction cleanAreaMethod(method=''){\n  return cleanMethodLabel(method);\n}\n\n/** Sanitize Areas index once at load */\nfunction useAreasDbCleaned(){\n  const [index, setIndex] = useState({});\n  useEffect(() => {\n    let alive = true;\n    (async () => {\n      try{\n        const res = await fetch(AREAS_URL, { cache:'no-store' });\n        const raw = await res.json();\n        const out = {};\n        for (const [region, maps] of Object.entries(raw || {})) {\n          for (const [mapName, entries] of Object.entries(maps || {})) {\n            // Ignore placeholder maps made entirely of dashes\n            if (/^-+$/.test(mapName)) continue;\n            const cleaned = [];\n            for (const e of entries || []) {\n              const method = cleanAreaMethod(e.method || '');\n              const rarity = e.rarity || '';\n              const speciesRaw = cleanSpeciesName(e.pokemon || '');\n              if (!speciesRaw) continue;\n\n              const mon = getMon(speciesRaw) || getMon(titleCase(speciesRaw));\n              if (!mon) continue; // drop broken / unmatched\n              cleaned.push({\n                monId: mon.id,\n                monName: mon.name,   // canonical\n                method,\n                rarity\n              });\n            }\n            if (cleaned.length) {\n              if (!out[region]) out[region] = {};\n              out[region][mapName] = cleaned;\n            }\n          }\n        }\n        if (alive) setIndex(out);\n      }catch(e){ console.error('load areas index failed', e); setIndex({}); }\n    })();\n    return () => { alive = false; };\n  }, []);\n  return index;\n}\n\nfunction useTmLocations(){\n  const [index, setIndex] = useState({});\n  useEffect(() => {\n    let alive = true;\n    (async () => {\n      try {\n        const res = await fetch(TM_URL, { cache:'no-store' });\n        const json = await res.json();\n        if (alive) setIndex(json || {});\n      } catch (e) {\n        console.error('load tm locations failed', e);\n        if (alive) setIndex({});\n      }\n    })();\n    return () => { alive = false; };\n  }, []);\n  return index;\n}\n\n/** Group same Pokémon (per map) into one entry with multiple methods/rarities */\nfunction groupEntriesByMon(entries){\n  const byId = new Map();\n  for (const e of entries){\n    if (!byId.has(e.monId)){\n      byId.set(e.monId, {\n        monId: e.monId,\n        monName: e.monName,\n        methods: new Set(),\n        rarities: new Set()\n      });\n    }\n    const g = byId.get(e.monId);\n    if (e.method) g.methods.add(e.method);\n    if (e.rarity) g.rarities.add(e.rarity);\n  }\n  return [...byId.values()].map(g => ({\n    monId: g.monId,\n    monName: g.monName,\n    methods: [...g.methods].sort(),\n    rarities: [...g.rarities].sort()\n  }));\n}\n\n/* Normalize map names for grouping (Sinnoh Victory Road unification & split routes) */\nfunction normalizeMapForGrouping(region, mapName){\n  const r = String(region).toLowerCase().trim();\n  let m = String(mapName).trim();\n\n  // Merge halves like \"Route 212 (North)\" / \"(South)\" → \"Route 212\"\n  if (/^route\\s*\\d+\\b/i.test(m)) {\n    m = m.replace(/\\s*\\((north|south|east|west)\\)\\s*/i, '').trim();\n  }\n\n  if (r === 'sinnoh' && /victory\\s*road/i.test(m)) {\n    return 'Victory Road';\n  }\n  return m;\n}\n\n/* ---------- PokeAPI extras (abilities & evolutions) ---------- */\nfunction formatEvoTrigger(d){\n  if (!d) return '';\n  if (d.min_level) return `Level ${d.min_level}`;\n  if (d.item?.name) return `Use ${titleCase(d.item.name.replace(/-/g, ' '))}`;\n  if (d.trigger?.name === 'trade') return 'Trade';\n  if (d.trigger?.name === 'level-up' && d.time_of_day) {\n    return `Level up (${titleCase(d.time_of_day)})`;\n  }\n  if (d.trigger?.name) return titleCase(d.trigger.name.replace(/-/g, ' '));\n  return '';\n}\n\nfunction extractDex(url=''){ const m = url.match(/\\/pokemon-species\\/(\\d+)\\/?/); return m ? Number(m[1]) : null; }\n\nfunction buildEvolutionPaths(chain){\n  const paths = [];\n  function walk(node, path=[]){\n    const dex = extractDex(node.species.url);\n    const mon = getMonByDex(dex);\n    if (!mon) {\n      if (path.length) paths.push(path);\n      return;\n    }\n    const entry = { dex, mon, details: node.details || null };\n    const next = [...path, entry];\n    if (!node.evolves_to || node.evolves_to.length === 0){\n      paths.push(next);\n    } else {\n      for (const child of node.evolves_to){\n        walk({ ...child, details: child.evolution_details?.[0] || null }, next);\n      }\n    }\n  }\n  if (chain) walk(chain, []);\n  return paths;\n}\n\nfunction usePokeApiExtras(mon){\n  const cacheRef = useRef(new Map());\n  const [data, setData] = useState(null);\n  useEffect(() => {\n    if (!mon?.id){ setData(null); return; }\n    if (cacheRef.current.has(mon.id)) { setData(cacheRef.current.get(mon.id)); return; }\n    let alive = true;\n    (async () => {\n      try {\n        const pokeRes = await fetch(`https://pokeapi.co/api/v2/pokemon/${mon.id}`);\n        const poke = await pokeRes.json();\n       const abilities = await Promise.all((poke.abilities || []).map(async a => {\n          const abilityName = titleCase(a.ability.name.replace(/-/g,' '));\n          let desc = '';\n          try {\n            const abilityRes = await fetch(a.ability.url);\n            const abilityData = await abilityRes.json();\n            const entry = (abilityData.effect_entries || []).find(e => e.language?.name === 'en');\n            desc = (entry?.short_effect || entry?.effect || '').replace(/\\n/g, ' ');\n          } catch {}\n          return {\n            name: abilityName,\n            hidden: a.is_hidden,\n            desc\n          };\n        }));\n        const speciesRes = await fetch(`https://pokeapi.co/api/v2/pokemon-species/${mon.id}`);\n        const species = await speciesRes.json();\n        let evolutions = [];\n        if (species.evolution_chain?.url){\n          const chainRes = await fetch(species.evolution_chain.url);\n          const chain = await chainRes.json();\n          evolutions = buildEvolutionPaths(chain.chain);\n        }\n        const out = { abilities, evolutions };\n        cacheRef.current.set(mon.id, out);\n        if (alive) setData(out);\n      } catch(err){\n        console.error('pokeapi fetch failed', err);\n        if (alive) setData(null);\n      }\n    })();\n    return () => { alive = false; };\n  }, [mon]);\n  return data;\n}\n\n/* ======================= LIVE ROUTE MATCHING ======================= */\n\n/** Known alias fixes (expand as needed) — keys and values are compared after simplifyName(). */\nconst LIVE_ALIASES = {\n  \"oreburghcity\": \"oreburghcity\",\n  \"jubilifecity\": \"jubilifecity\",\n  \"mtcoronet\": \"mountcoronet\",\n  \"mtcoronet4f\": \"mountcoronet\",\n  \"victoryroad\": \"victoryroad\",\n};\n\n/** Turn a name into a minimal comparable key */\nfunction simplifyName(s='') {\n  return String(s)\n    .replace(/\\s+Ch\\.?\\s*\\d+\\b/ig, '')\n    .replace(/\\$[\\d,\\.]+/g, '')\n    .replace(/\\b(Sun|Mon|Tue|Tues|Wed|Thu|Thur|Fri|Sat|Sunday|Monday|Tuesday|Wednesday|Thursday|Friday|Saturday)\\b/ig, '')\n    .replace(/\\b\\d{1,2}:\\d{2}\\b/g, '')\n    .replace(/\\bmt\\.?\\b/ig, 'mount')\n    .replace(/\\s*\\([^)]*\\)\\s*/g, ' ')\n    .replace(/\\b(?:b\\d+f|\\d+f)\\b/ig, '')\n    .toLowerCase()\n    .replace(/[^a-z0-9 ]+/g, ' ')\n    .replace(/\\s+/g, ' ')\n    .trim()\n    .replace(/\\b(city|town|forest|cave|road|gate|outside|inside|entrance|exit)\\b/g, '')\n    .replace(/\\s+/g, '');\n}\n\nfunction aliasKey(s='') {\n  const key = simplifyName(s);\n  if (LIVE_ALIASES[key]) return LIVE_ALIASES[key];\n  return key;\n}\n\n/** Score similarity using token overlap & contains/startsWith bonuses */\nfunction scoreNames(a, b) {\n  if (!a || !b) return 0;\n  if (a === b) return 100;\n  let score = 0;\n  if (a.startsWith(b) || b.startsWith(a)) score += 25;\n  if (a.includes(b) || b.includes(a))   score += 20;\n  const numsA = (a.match(/\\d+/g) || []).join(',');\n  const numsB = (b.match(/\\d+/g) || []).join(',');\n  if (numsA && numsA === numsB) score += 30;\n  const lenRatio = Math.min(a.length, b.length) / Math.max(a.length, b.length);\n  score += Math.round(lenRatio * 15);\n  return score;\n}\n\n/** Find best map match across regions; returns { region, displayMap } or null. */\nfunction findBestMapName(hudText, areasIndex){\n  if (!hudText) return null;\n  const needleKey = aliasKey(hudText);\n  let best = null, bestScore = -1;\n  for (const [region, maps] of Object.entries(areasIndex || {})) {\n    for (const [mapName] of Object.entries(maps || {})) {\n      const candidateKey = aliasKey(mapName);\n      if (candidateKey === needleKey) {\n        return { region, displayMap: normalizeMapForGrouping(region, mapName), rawMap: mapName };\n      }\n      const s = scoreNames(candidateKey, needleKey);\n      if (s > bestScore) {\n        bestScore = s;\n        best = { region, displayMap: normalizeMapForGrouping(region, mapName), rawMap: mapName, score: s };\n      }\n    }\n  }\n  if (best && best.score >= 35) return best;\n  return null;\n}\n\n/**\n * Given raw HUD text, strip any leading garbage and try to locate a\n * known map name.  Returns { cleaned, best } where `cleaned` is the\n * matched substring and `best` is the map match (or null).\n */\nfunction findBestMapInText(text, areasIndex){\n  const words = String(text).split(/\\s+/);\n  let bestMatch = null;\n  let bestClean = text;\n  let bestScore = -1;\n  for (let i = 0; i \u003c words.length; i++) {\n    const candidate = words.slice(i).join(' ');\n    const match = findBestMapName(candidate, areasIndex);\n    if (match) {\n      const s = scoreNames(aliasKey(match.rawMap), aliasKey(candidate));\n      if (s > bestScore) { bestScore = s; bestMatch = match; bestClean = candidate; }\n    }\n  }\n  return { cleaned: bestClean, best: bestMatch };\n}\n\n/* ---------- Region candidates + helpers ---------- */\nfunction listRegionCandidates(areasIndex, displayMap){\n  const out = [];\n  for (const [region, maps] of Object.entries(areasIndex || {})) {\n    for (const [mapName] of Object.entries(maps || {})) {\n      const norm = normalizeMapForGrouping(region, mapName);\n      if (norm === displayMap) { out.push(region); break; }\n    }\n  }\n  return [...new Set(out)];\n}\nfunction buildGroupedEntries(areasIndex, displayMap, regionFilter){\n  const merged = [];\n  for (const [reg, maps] of Object.entries(areasIndex || {})) {\n    if (regionFilter && reg !== regionFilter) continue;\n    for (const [mapName, list] of Object.entries(maps || {})) {\n      const norm = normalizeMapForGrouping(reg, mapName);\n      if (norm === displayMap) merged.push(...(list||[]));\n    }\n  }\n  return groupEntriesByMon(merged);\n}\n\n/* ======================= LIVE ROUTE: WS client + Panel ======================= */\n\nconst STALE_AFTER_MS = 6000;\n\nfunction normalizeHudText(s=''){\n  let t = String(s).trim();\n  t = t.replace(/\\s+Ch\\.?\\s*\\d+\\b/i, '');\n  t = t.replace(/\\s{2,}/g,' ').trim();\n  // Treat OCR results that are just dashes as empty/no data\n  if (/^-+$/.test(t)) return '';\n  return t;\n}\n\nclass LiveRouteClient {\n  constructor(){\n    this.ws = null;\n    this.listeners = new Set();\n    this.reconnectTimer = null;\n    this.pathToggle = false;\n    this.lastMsgTs = 0;\n    this.lastPayload = null; // cache last message\n  }\n  connect(){\n    if (this.ws && (this.ws.readyState === WebSocket.OPEN || this.ws.readyState === WebSocket.CONNECTING)) return;\n    try{\n      const url = this.pathToggle ? 'ws://127.0.0.1:8765/live/' : 'ws://127.0.0.1:8765/live';\n      this.ws = new WebSocket(url);\n\n      this.ws.onmessage = (ev) => {\n        this.lastMsgTs = Date.now();\n        let payload = ev.data;\n        try { payload = JSON.parse(ev.data); } catch {}\n        this.lastPayload = payload; // cache\n        this.listeners.forEach(fn => fn(payload));\n      };\n      const onClose = () => {\n        this.pathToggle = !this.pathToggle;\n        this.scheduleReconnect();\n      };\n      this.ws.onclose = onClose;\n      this.ws.onerror = onClose;\n    }catch{\n      this.scheduleReconnect();\n    }\n  }\n  on(fn){\n    this.listeners.add(fn);\n    // Immediately replay last message so the tab shows data when you return\n    if (this.lastPayload !== null) {\n      try { fn(this.lastPayload); } catch {}\n    }\n    return () => this.listeners.delete(fn);\n  }\n  scheduleReconnect(){\n    if (this.reconnectTimer) return;\n    this.reconnectTimer = window.setTimeout(()=> {\n      this.reconnectTimer = null;\n      this.connect();\n    }, 1500);\n  }\n  isOpen(){\n    return !!this.ws && this.ws.readyState === WebSocket.OPEN;\n  }\n  forceReconnect(){\n    try { if (this.ws) this.ws.close(); } catch {}\n    this.ws = null;\n    this.lastPayload = null;          // \u003c-- clear cached message so UI resets\n    this.pathToggle = !this.pathToggle;\n    setTimeout(()=> this.connect(), 100);\n  }\n}\nconst liveRouteClient = new LiveRouteClient();\n\nfunction coerceIncoming(msg){\n  if (!msg) return null;\n  if (typeof msg === 'string') {\n    // Plain route or tagged variants\n    const mTagged = msg.match(/^(?:ROUTE\\|route:)?\\s*(.+)$/i);\n    if (mTagged) return { routeText: mTagged[1], confidence: null };\n    // GUESS: \"...\"\n    const m = msg.match(/GUESS:\\s*\"?([^\"]+?)\"?\\s*$/i);\n    if (m) return { routeText: m[1], confidence: null };\n    if (msg.trim() === 'NO_ROUTE') return { routeText: '', confidence: 0 };\n    return null;\n  }\n  const src = msg.payload || msg.data || msg;\n  let t = src.text ?? src.route ?? src.name ?? src.guess ?? null;\n  if (!t && typeof src.type === 'string' && src.type === 'no_route') t = '';\n  if (!t && typeof src.line === 'string') {\n    const m = src.line.match(/GUESS:\\s*\"?([^\"]+?)\"?\\s*$/i);\n    if (m) t = m[1];\n  }\n  if (!t && typeof src.message === 'string') {\n    const m = src.message.match(/GUESS:\\s*\"?([^\"]+?)\"?\\s*$/i);\n    if (m) t = m[1];\n  }\n  let c = src.confidence ?? src.conf ?? src.c\n  if (typeof c === 'string') { const f = parseFloat(c); if (!Number.isNaN(f)) c = f; }\n  return (t !== null) ? { routeText: t, confidence: c } : null;\n}\n\n/* ---------- RegionPicker (segmented buttons, right-aligned) ---------- */\nfunction RegionPicker({ regions, value, onChange }) {\n  if (!regions || regions.length \u003c 2) return null;\n  return (\n    \u003cdiv className=\"flex items-center gap-2\">\n      \u003cspan className=\"text-slate-400 text-sm\">Region\u003c/span>\n      \u003cdiv className=\"inline-flex rounded-xl bg-slate-700/60 p-0.5\">\n        {regions.map((r) => {\n          const active = value === r;\n          return (\n            \u003cbutton\n              key={r}\n              onClick={() => onChange(r)}\n              className={\n                \"px-2.5 py-1 text-sm rounded-lg transition-colors \" +\n                (active\n                  ? \"bg-emerald-600 text-white\"\n                  : \"text-slate-200 hover:bg-slate-600/60\")\n              }\n              title={`Show ${r}`}\n            >\n              {titleCase(r)}\n            \u003c/button>\n          );\n        })}\n      \u003c/div>\n    \u003c/div>\n  );\n}\n\n/* ======================= LIVE ROUTE PANEL ======================= */\n\nfunction LiveRoutePanel({ areasIndex, onViewMon }){\n  const [rawText, setRawText] = useState('');\n  const [confidence, setConfidence] = useState(null);\n  const [displayMap, setDisplayMap] = useState(null);\n  const [region, setRegion] = useState(null);\n  const [entries, setEntries] = useState([]);\n  const [connected, setConnected] = useState(false);\n  const [isStale, setIsStale] = useState(false);\n  const [regionChoices, setRegionChoices] = useState([]);\n\n  // Handle messages\n  useEffect(() => {\n    const off = liveRouteClient.on((msg) => {\n      const coerced = coerceIncoming(msg);\n      if (!coerced) return;\n\n      let cleaned = normalizeHudText(coerced.routeText);\n      if (DEBUG_LIVE) console.log('[LIVE] OCR raw:', coerced.routeText, '→ cleaned:', cleaned);\n\n      const { cleaned: trimmed, best } = findBestMapInText(cleaned, areasIndex);\n      if (!best) return; // ignore noisy frames\n      cleaned = trimmed;\n\n      setRawText(cleaned);\n      setConfidence(coerced.confidence ?? null);\n\n      const targetName = best.displayMap;\n\n        const choices = listRegionCandidates(areasIndex, targetName);\n        setRegionChoices(choices);\n\n        // choose region: saved pref → best → first choice\n      const prefKey = `regionPref:${targetName}`;\n      let picked = localStorage.getItem(prefKey);\n      if (picked && !choices.includes(picked)) picked = null;\n      const chosen = picked || best.region || choices[0] || null;\n\n      setRegion(chosen);\n      setDisplayMap(targetName);\n      setEntries(buildGroupedEntries(areasIndex, targetName, chosen));\n      });\n\n    liveRouteClient.connect();\n\n    // heartbeat watcher for stale/connected pill\n    const pulse = setInterval(() => {\n      setConnected(liveRouteClient.isOpen());\n      const last = liveRouteClient.lastMsgTs || 0;\n      setIsStale(!!rawText && Date.now() - last > STALE_AFTER_MS);\n    }, 1000);\n\n    // NEW: respond to \"Reload OCR\" signal (clear panel + reconnect)\n    const onForce = () => {\n      setRawText('');\n      setConfidence(null);\n      setDisplayMap(null);\n      setRegion(null);\n      setEntries([]);\n      setRegionChoices([]);\n      liveRouteClient.forceReconnect();\n    };\n    window.addEventListener('force-live-reconnect', onForce);\n\n    // Reconnect when tab becomes visible again (tab-away fix)\n    const onVis = () => {\n      if (document.visibilityState === 'visible') {\n        const stale = Date.now() - (liveRouteClient.lastMsgTs || 0) > STALE_AFTER_MS;\n        if (!liveRouteClient.isOpen() || stale) {\n          liveRouteClient.forceReconnect();\n        }\n      }\n    };\n    document.addEventListener('visibilitychange', onVis);\n    // Also reconnect on window focus (covers some browsers)\n    const onFocus = () => {\n      const stale = Date.now() - (liveRouteClient.lastMsgTs || 0) > STALE_AFTER_MS;\n      if (!liveRouteClient.isOpen() || stale) {\n        liveRouteClient.forceReconnect();\n      }\n    };\n    window.addEventListener('focus', onFocus);\n\n    return () => {\n      off();\n      clearInterval(pulse);\n      window.removeEventListener('force-live-reconnect', onForce);\n      document.removeEventListener('visibilitychange', onVis);\n      window.removeEventListener('focus', onFocus);\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [areasIndex, rawText]);\n\n  const statusPill = (() => {\n    if (!connected) return \u003cspan className=\"px-2 py-1 rounded-xl bg-red-600/20 text-red-300 text-xs\">Disconnected\u003c/span>;\n    if (isStale)   return \u003cspan className=\"px-2 py-1 rounded-xl bg-yellow-600/20 text-yellow-300 text-xs\">Stale\u003c/span>;\n    return \u003cspan className=\"px-2 py-1 rounded-xl bg-green-600/20 text-green-300 text-xs\">Live\u003c/span>;\n  })();\n\n  const confPct = formatConfidence(confidence);\n\n  // When user changes region via segmented buttons\n  const handleRegionChange = (r) => {\n    setRegion(r);\n    if (displayMap) {\n      const prefKey = `regionPref:${displayMap}`;\n      localStorage.setItem(prefKey, r || '');\n      setEntries(buildGroupedEntries(areasIndex, displayMap, r));\n    }\n  };\n\n  return (\n    \u003cdiv className=\"p-3\" style={{ display:'flex', flexDirection:'column', gap:12 }}>\n      \u003cdiv style={{ display:'flex', justifyContent:'space-between', alignItems:'baseline' }}>\n        \u003cdiv className=\"label-muted\">\n          Live Location: \u003cspan style={{ fontWeight:800 }}>{rawText || '—'}\u003c/span>\n          {SHOW_CONFIDENCE && (confPct !== null) && (\n            \u003cspan className=\"text-slate-400 ml-2\">({confPct}% Confidence)\u003c/span>\n          )}\n        \u003c/div>\n        \u003cdiv className=\"label-muted\">{statusPill}\u003c/div>\n      \u003c/div>\n\n      {!rawText && (\n        \u003cdiv className=\"label-muted\">\n          \u003cb>LiveRouteOCR\u003c/b> is attempting to find Route Data. Click Into your PokeMMO window. Move around a bit or adjust your UI scaling if it still can't find the route.\n        \u003c/div>\n      )}\n\n      {rawText && !displayMap && (\n        \u003cdiv className=\"label-muted\">No usable route information found. Move around a bit or make sure the route is displayed on screen.\u003c/div>\n      )}\n\n      {displayMap && (\n        \u003cdiv style={styles.areaCard}>\n          \u003cdiv style={{ display:'flex', justifyContent:'space-between', alignItems:'center' }}>\n            \u003cdiv>\n              \u003cdiv style={{ fontWeight:800, fontSize:16 }}>\n                {displayMap} {region ? \u003cspan className=\"label-muted\">({titleCase(region)})\u003c/span> : null}\n              \u003c/div>\n              \u003cdiv className=\"label-muted\">{entries.length} Pokémon\u003c/div>\n            \u003c/div>\n            {/* Segmented buttons on the RIGHT */}\n            \u003cRegionPicker regions={regionChoices} value={region} onChange={handleRegionChange} />\n          \u003c/div>\n\n          {entries.length === 0 ? (\n            \u003cdiv className=\"label-muted\" style={{ marginTop:8 }}>No encounter data found for this area.\u003c/div>\n          ) : (\n            \u003cdiv style={{ ...styles.gridCols, marginTop:10 }}>\n              {entries.map((g, idx) => {\n                const mon = getMon(g.monName);\n                return (\n                  \u003cdiv key={idx} style={styles.monRow}>\n                    \u003cSprite mon={mon} size={36} alt={g.monName} />\n                    \u003cdiv style={{ flex:1, minWidth:0 }}>\n                      \u003cdiv style={{ fontWeight:700 }}>{g.monName}\u003c/div>\n                      \u003cdiv style={{ display:'flex', gap:6, flexWrap:'wrap', marginTop:4 }}>\n                        {g.methods.map(m => \u003cMethodPill key={`m-${idx}-${m}`} method={m} />)}\n                        {g.rarities.map(r => \u003cRarityPill key={`r-${idx}-${r}`} rarity={r} />)}\n                      \u003c/div>\n                    \u003c/div>\n                    {mon && (\n                      \u003cbutton\n                        className=\"btn\"\n                        style={styles.viewBtn}\n                        onClick={() => onViewMon && onViewMon(mon)}\n                        title=\"Open Pokémon\"\n                      >View\u003c/button>\n                    )}\n                  \u003c/div>\n                );\n              })}\n            \u003c/div>\n          )}\n        \u003c/div>\n      )}\n\n      {DEBUG_LIVE && rawText && (\n        \u003cdiv className=\"label-muted\" style={{ fontSize:12, opacity:.6 }}>\n          Debug key: \u003ccode>{aliasKey(rawText)}\u003c/code>\n        \u003c/div>\n      )}\n    \u003c/div>\n  );\n}\n\n/* ======================= REVERSE AREAS → MON INDEX ======================= */\nfunction buildReverseAreasIndex(areasClean) {\n  const rev = new Map();\n  for (const [region, maps] of Object.entries(areasClean || {})) {\n    for (const [mapName, entries] of Object.entries(maps || {})) {\n      const grouped = groupEntriesByMon(entries);\n      for (const g of grouped) {\n        if (!rev.has(g.monId)) rev.set(g.monId, []);\n        rev.get(g.monId).push({\n          region,\n          map: normalizeMapForGrouping(region, mapName),\n          methods: g.methods || [],\n          rarities: g.rarities || []\n        });\n      }\n    }\n  }\n  return rev;\n}\n\n/* ======================= APP ======================= */\nfunction App(){\n  const [query, setQuery]       = useState('');\n  const [areaRegion, setAreaRegion] = useState('All');\n  const [showRegionMenu, setShowRegionMenu] = useState(false);\n  const [selected, setSelected] = useState(null);\n  const [mode, setMode]         = useState('pokemon'); // 'pokemon' | 'areas' | 'tm' | 'live'\n\n  const locIndex   = useLocationsDb();\n  const areasClean = useAreasDbCleaned();\n  const tmIndex    = useTmLocations();\n  const areasRevByMon = useMemo(() => buildReverseAreasIndex(areasClean), [areasClean]); // NEW\n  const extras = usePokeApiExtras(selected);\n\n  const [headerSprite] = useState(() => {\n    const withSprite = DEX_LIST.filter(d => spriteSources(d).length > 0);\n    return withSprite.length ? spriteSources(withSprite[Math.floor(Math.random()*withSprite.length)])[0] : null;\n  });\n  useEffect(() => { document.title = APP_TITLE; }, []);\n  const headerSrc = headerSprite || TRANSPARENT_PNG;\n\n  useEffect(() => {\n    setShowRegionMenu(false);\n    if (mode !== 'pokemon') setSelected(null);\n  }, [mode]);\n  useEffect(() => {\n    (async () => {\n      try {\n        const current = await window.app?.getVersion?.().catch(() => null);\n        if (current) {\n          const last = localStorage.getItem('last-version');\n          if (last !== current) {\n            openPatchNotes();\n            localStorage.setItem('last-version', current);\n          }\n        }\n      } catch (err) {\n        console.error('Version check failed', err);\n      }\n    })();\n  }, []);\n\n// (Removed: legacy OCR setup auto-open)\n\n  // Search by Pokémon\n  const results = React.useMemo(() => {\n    const q = query.trim().toLowerCase();\n    if (!q || mode!=='pokemon') return [];\n    return DEX_LIST.filter(p => p.name.toLowerCase().includes(q) || String(p.id) === q).slice(0, 24);\n  }, [query, mode]);\n\n  // Search by Area (cleaned + grouped) with Sinnoh Victory Road unified\n  const areaHits = React.useMemo(() => {\n    if (mode!=='areas') return [];\n    const q = query.trim().toLowerCase();\n    if (q.length \u003c 2) return [];\n    const buckets = new Map();\n    const regionKey = normalizeRegion(areaRegion);\n    for (const [region, maps] of Object.entries(areasClean)) {\n      const regionNorm = normalizeRegion(region);\n      if (regionKey !== 'all' && regionNorm !== regionKey) continue;\n      for (const [mapName, entries] of Object.entries(maps)) {\n        const displayMap = normalizeMapForGrouping(region, mapName);\n        if (!displayMap.toLowerCase().includes(q)) continue;\n        const key = `${region}|||${displayMap}`;\n        if (!buckets.has(key)) buckets.set(key, { region, map: displayMap, entries: [] });\n        buckets.get(key).entries.push(...entries);\n      }\n    }\n    const hits = [];\n    for (const { region, map, entries } of buckets.values()) {\n      const regionNorm = normalizeRegion(region);\n      if (regionKey !== 'all' && regionNorm !== regionKey) continue;\n      const grouped = groupEntriesByMon(entries);\n      if (grouped.length) hits.push({ region, map, count: grouped.length, entries: grouped });\n    }\n    hits.sort((a,b)=> a.region.localeCompare(b.region) || a.map.localeCompare(b.map));\n    return hits.slice(0, 30);\n }, [query, areasClean, mode, areaRegion]);\n\n  const tmHits = React.useMemo(() => {\n    if (mode !== 'tm') return [];\n    const q = query.trim().toLowerCase();\n    if (!q) return [];\n    const regionKey = normalizeRegion(areaRegion);\n    const hits = [];\n    for (const [region, entries] of Object.entries(tmIndex)) {\n      const regionNorm = normalizeRegion(region);\n      if (regionKey !== 'all' && regionNorm !== regionKey) continue;\n      for (const entry of entries || []) {\n        if (entry.tm.toLowerCase().includes(q)) {\n          hits.push({ ...entry, region });\n        }\n      }\n    }\n    hits.sort((a,b)=> a.region.localeCompare(b.region) || a.tm.localeCompare(b.tm));\n    return hits;\n  }, [query, tmIndex, mode, areaRegion]);\n\n  // Selected Pokémon details (MERGED sources)\n  const resolved = React.useMemo(() => {\n    if (!selected) return null;\n\n    const norm = normalizeKey(selected.name);\n    const baseLocsRaw = (() => {\n      const locEntry = locIndex[norm] || locIndex[`and-${norm}`] || locIndex[norm.replace(/^and-/, '')];\n      return Array.isArray(locEntry?.locations) ? locEntry.locations : [];\n    })();\n\n    // Normalize base locations to array-of-arrays form\n    const baseLocs = baseLocsRaw.map(l => ({\n      region: titleCase(l.region || 'Unknown'),\n      map: normalizeMapForGrouping(l.region || 'Unknown', l.map || ''),\n      method: Array.isArray(l.method) ? l.method.filter(Boolean) : (l.method ? [l.method] : []),\n      rarity: Array.isArray(l.rarity) ? l.rarity.filter(Boolean) : (l.rarity ? [l.rarity] : []),\n    }));\n\n    // Extra from Areas reverse index\n    const extraLocs = (areasRevByMon.get(selected.id) || []).map(e => ({\n      region: titleCase(e.region),\n      map: e.map,\n      method: (e.methods || []).filter(Boolean),\n      rarity: (e.rarities || []).filter(Boolean),\n    }));\n\n    // Merge & dedupe by region+map; union methods/rarities\n    const byKey = new Map();\n    for (const src of [...baseLocs, ...extraLocs]) {\n      if (!src.map) continue;\n      const key = `${src.region}|${src.map}`;\n      const prev = byKey.get(key) || { region: src.region, map: src.map, method: [], rarity: [] };\n      prev.method.push(...(src.method || []));\n      prev.rarity.push(...(src.rarity || []));\n      byKey.set(key, prev);\n    }\n\n    const mergedLocs = [...byKey.values()].map(l => ({\n      ...l,\n      method: [...new Set(l.method)],\n      rarity: [...new Set(l.rarity)],\n    }));\n\n    const types = (selected.types || []).map(normalizeType);\n    const moveInfo = MOVESETS_BY_ID.get(selected.id) || {};\n    const eggGroups = moveInfo.eggGroups || [];\n    const moves = {\n      start: moveInfo.start || [],\n      lv: moveInfo.lv || [],\n      tutor: moveInfo.tutor || [],\n      tmhm: moveInfo.tmhm || [],\n      egg: moveInfo.egg || []\n    };\n    return {\n      ...selected,\n      types,\n      eggGroups,\n      moves,\n      weakness: computeWeakness(types),\n      locations: mergedLocs\n    };\n  }, [selected, locIndex, areasRevByMon]);\n\n  // Group locations by region\n  const byRegion = React.useMemo(() => {\n    if (!resolved?.locations?.length) return [];\n    const groups = new Map();\n    for (const L of resolved.locations) {\n      const reg = titleCase(L.region || 'Unknown');\n      if (!groups.has(reg)) groups.set(reg, []);\n      groups.get(reg).push(L);\n    }\n    const order = ['Kanto','Johto','Hoenn','Sinnoh','Unova','Unknown'];\n    return [...groups.entries()].sort((a,b) => order.indexOf(a[0]) - order.indexOf(b[0]));\n  }, [resolved]);\n\n  return (\n    \u003c>\n      {/* App-wide overlay controls (top-right) */}\n      \u003cdiv style={{ position:'fixed', top:10, right:12, zIndex:9999, display:'flex', gap:8 }}>\n        \u003cPatchNotesButton />\n        \u003cOptionsMenu />\n      \u003c/div>\n\n      \u003cdiv className=\"container\">\n        {/* Header */}\n        \u003cdiv className=\"header\" style={{ alignItems:'center' }}>\n          \u003cimg src={headerSrc} alt=\"\" style={{ width:44, height:44, objectFit:'contain', imageRendering:'pixelated' }} />\n          \u003ch1 style={{ marginLeft:8 }}>3&apos;s PokeMMO Tool\u003c/h1>\n        \u003c/div>\n\n        {/* Search / Mode Card */}\n        \u003cdiv style={{ ...styles.card, marginBottom:16 }}>\n          \u003cdiv style={{ display:'flex', justifyContent:'space-between', alignItems:'center', marginBottom:10 }}>\n            \u003cdiv style={styles.segWrap}>\n              \u003cbutton style={styles.segBtn(mode==='pokemon')} onClick={()=>setMode('pokemon')}>Pokémon\u003c/button>\n              \u003cbutton style={styles.segBtn(mode==='areas')} onClick={()=>setMode('areas')}>Areas\u003c/button>\n              \u003cbutton style={styles.segBtn(mode==='tm')} onClick={()=>setMode('tm')}>TM Locations\u003c/button>\n              \u003cbutton style={styles.segBtn(mode==='live')}    onClick={()=>setMode('live')}>Live\u003c/button>\n            \u003c/div>\n          \u003c/div>\n\n          {/* Context label + search input (hidden for Live) */}\n          {mode!=='live' && (\n            \u003c>\n               \u003cdiv style={{ display:'flex', justifyContent:'space-between', alignItems:'center', marginBottom:8 }}>\n                \u003cdiv className=\"label-muted\">\n                  {mode==='pokemon' ? 'Search by name or Dex #' : mode==='areas' ? 'Search by route/area name' : 'Search by TM name'}\n                \u003c/div>\n                {(mode==='areas' || mode==='tm') && (\n                  \u003cdiv style={{ position:'relative' }}>\n                    \u003cbutton\n                      type=\"button\"\n                      onClick={()=> setShowRegionMenu(v => !v)}\n                      className=\"region-btn\"\n                    >\n                      {areaRegion === 'All' ? 'Region' : areaRegion}\n                    \u003c/button>\n                    {showRegionMenu && (\n                      \u003cdiv className=\"region-menu\">\n                        {['All','Kanto','Johto','Hoenn','Sinnoh','Unova'].map(r => (\n                          \u003cbutton\n                            type=\"button\"\n                            key={r}\n                            onClick={()=> { setAreaRegion(r); setShowRegionMenu(false); }}\n                            className={r===areaRegion ? 'active' : undefined}\n                          >\n                            {r}\n                          \u003c/button>\n                        ))}\n                      \u003c/div>\n                    )}\n                  \u003c/div>\n                )}\n              \u003c/div>\n              \u003cinput\n                value={query}\n                onChange={(e)=> setQuery(e.target.value)}\n                placeholder={mode==='pokemon' ? 'e.g. Garchomp or 445' : 'e.g. Victory Road, Viridian Forest, Route 10' : 'e.g. Giga Drain, Payback'}\n                className=\"input\"\n                style={{ height:44, borderRadius:10, fontSize:16 }}\n              />\n            \u003c/>\n          )}\n\n          {/* Live route panel */}\n          {mode==='live' && (\n            \u003cdiv style={{ marginTop:4 }}>\n              \u003cLiveRoutePanel\n                areasIndex={areasClean}\n                onViewMon={(mon) => { setSelected(mon); setMode('pokemon'); }}\n              />\n            \u003c/div>\n          )}\n\n          {/* Pokémon results */}\n          {mode==='pokemon' && !!results.length && (\n            \u003cdiv className=\"result-grid\" style={{ marginTop:12 }}>\n              {results.map(p => {\n                const mon = p;\n                const t = (p.types || []).map(normalizeType);\n                return (\n                  \u003cbutton\n                    key={`${p.id}-${p.name}`}\n                    onClick={()=>{ setSelected(p); setQuery(''); }}\n                    className=\"result-tile\"\n                    style={{ alignItems:'center', padding:10, borderRadius:12, border:'1px solid #262626', background:'#141414' }}\n                  >\n                    \u003cSprite mon={mon} size={42} alt={p.name} />\n                    \u003cdiv style={{ textAlign:'left' }}>\n                      \u003cdiv style={{ fontWeight:800 }}>{titleCase(p.name)}\u003c/div>\n                      \u003cdiv className=\"label-muted\">Dex #{p.id}\u003c/div>\n                      \u003cdiv style={{ display:'flex', gap:6, marginTop:6 }}>\n                        {t.map(tp => \u003cTypePill key={tp} t={tp} compact />)}\n                      \u003c/div>\n                    \u003c/div>\n                  \u003c/button>\n                );\n              })}\n            \u003c/div>\n          )}\n\n          {/* Area results */}\n          {mode==='areas' && !!areaHits.length && (\n            \u003cdiv style={{ marginTop:12, display:'grid', gap:12 }}>\n              {areaHits.map(hit => (\n                \u003cdiv key={`${hit.region}-${hit.map}`} style={styles.areaCard}>\n                  \u003cdiv style={{ display:'flex', justifyContent:'space-between', alignItems:'baseline' }}>\n                    \u003cdiv style={{ fontWeight:800, fontSize:16 }}>\n                      {hit.map} \u003cspan className=\"label-muted\">({hit.region})\u003c/span>\n                    \u003c/div>\n                    \u003cdiv className=\"label-muted\">{hit.count} Pokémon\u003c/div>\n                  \u003c/div>\n\n                  \u003cdiv style={{ ...styles.gridCols, marginTop:10 }}>\n                    {hit.entries.map((g, idx) => {\n                      const mon = getMon(g.monName);\n                      return (\n                        \u003cdiv key={idx} style={styles.monRow}>\n                          \u003cSprite mon={mon} size={36} alt={g.monName} />\n                          \u003cdiv style={{ flex:1, minWidth:0 }}>\n                            \u003cdiv style={{ fontWeight:700 }}>{g.monName}\u003c/div>\n                            \u003cdiv style={{ display:'flex', gap:6, flexWrap:'wrap', marginTop:4 }}>\n                              {g.methods.map(m => \u003cMethodPill key={`m-${m}`} method={m} />)}\n                              {g.rarities.map(r => \u003cRarityPill key={`r-${r}`} rarity={r} />)}\n                            \u003c/div>\n                          \u003c/div>\n                          {mon && (\n                            \u003cbutton\n                              className=\"btn\"\n                              style={styles.viewBtn}\n                              onClick={() => {\n                                setSelected(mon);\n                                setMode('pokemon');\n                                setQuery('');\n                              }}\n                              title=\"Open Pokémon\"\n                            >View\u003c/button>\n                          )}\n                        \u003c/div>\n                      );\n                    })}\n                  \u003c/div>\n                \u003c/div>\n              ))}\n            \u003c/div>\n          )}\n          \n          {/* TM results */}\n          {mode==='tm' && !!tmHits.length && (\n            \u003cdiv style={{ marginTop:12, display:'grid', gap:12 }}>\n              {tmHits.map((hit, idx) => (\n                \u003cdiv key={`${hit.region}-${hit.tm}-${idx}`} style={styles.areaCard}>\n                  \u003cdiv style={{ fontWeight:800, fontSize:16 }}>\n                    {hit.tm} \u003cspan className=\"label-muted\">({hit.region})\u003c/span>\n                  \u003c/div>\n                  \u003cdiv style={{ marginTop:6 }}>{hit.location}\u003c/div>\n                \u003c/div>\n              ))}\n            \u003c/div>\n          )}\n        \u003c/div>\n\n        {/* Detail Panel (Pokémon) */}\n        {mode==='pokemon' && resolved && (\n          \u003cdiv className=\"grid\">\n            {/* Left: Pokémon card */}\n            \u003cdiv style={styles.card}>\n              \u003cdiv style={{ display:'flex', gap:12 }}>\n                \u003cSprite mon={selected} size={120} alt={resolved.name} />\n                \u003cdiv>\n                  \u003cdiv style={{ fontSize:22, fontWeight:900 }}>\n                    {titleCase(resolved.name)} \u003cspan className=\"label-muted\">#{resolved.id}\u003c/span>\n                  \u003c/div>\n                  \u003cdiv style={{ display:'flex', gap:12, marginTop:6, flexWrap:'wrap', alignItems:'center' }}>\n                    \u003cdiv style={{ display:'flex', gap:6, alignItems:'center' }}>\n                      \u003cspan className=\"label-muted\" style={{ fontWeight:700 }}>Type:\u003c/span>\n                      {(resolved.types || []).map(tp => \u003cTypePill key={tp} t={tp} />)}\n                    \u003c/div>\n                    {resolved.eggGroups?.length > 0 && (\n                      \u003cdiv style={{ display:'flex', gap:6, alignItems:'center' }}>\n                        \u003cspan className=\"label-muted\" style={{ fontWeight:700 }}>Egg Group:\u003c/span>\n                        {resolved.eggGroups.map(g => \u003cEggGroupPill key={g} group={g} />)}\n                      \u003c/div>\n                    )}\n                   {extras?.abilities?.length > 0 && (\n                      \u003cdiv style={{ display:'flex', gap:6, alignItems:'flex-start' }}>\n                        \u003cspan className=\"label-muted\" style={{ fontWeight:700 }}>Abilities:\u003c/span>\n                        \u003cdiv style={{ display:'flex', flexDirection:'column', gap:4 }}>\n                          {extras.abilities.filter(a => !a.hidden).map((a, i) => (\n                            \u003cAbilityPill key={`${a.name}-${i}`} label={`${i+1}`} name={a.name} desc={a.desc} />\n                          ))}\n                          {extras.abilities.filter(a => a.hidden).map((a, i) => (\n                            \u003cAbilityPill key={`${a.name}-h-${i}`} label=\"Hidden\" name={a.name} desc={a.desc} />\n                          ))}\n                        \u003c/div>\n                      \u003c/div>\n                    )}\n                  \u003c/div>\n                \u003c/div>\n              \u003c/div>\n\n              {/* Weakness table */}\n              \u003cdiv style={{ marginTop:16 }}>\n                \u003cdiv className=\"label-muted\" style={{ fontWeight:700, marginBottom:8 }}>Type Matchups\u003c/div>\n                \u003cdiv style={{ display:'grid', gridTemplateColumns:'repeat(auto-fit, minmax(160px, 1fr))', gap:8 }}>\n                  \u003cdiv style={{ border:'1px solid #2b2b2b', borderRadius:8, padding:'8px 10px', background:'#141414' }}>\n                    \u003cdiv style={{ fontWeight:800, marginBottom:6 }}>4× Weak\u003c/div>\n                    {resolved.weakness.x4.length ? (\n                      \u003cdiv style={{ display:'flex', gap:6, flexWrap:'wrap' }}>\n                        {resolved.weakness.x4.map(t => \u003cTypePill key={`x4-${t}`} t={t} compact />)}\n                      \u003c/div>\n                    ) : \u003cdiv className=\"label-muted\">None\u003c/div>}\n                  \u003c/div>\n                  \u003cdiv style={{ border:'1px solid #2b2b2b', borderRadius:8, padding:'8px 10px', background:'#141414' }}>\n                    \u003cdiv style={{ fontWeight:800, marginBottom:6 }}>2× Weak\u003c/div>\n                    {resolved.weakness.x2.length ? (\n                      \u003cdiv style={{ display:'flex', gap:6, flexWrap:'wrap' }}>\n                        {resolved.weakness.x2.map(t => \u003cTypePill key={`x2-${t}`} t={t} compact />)}\n                      \u003c/div>\n                    ) : \u003cdiv className=\"label-muted\">None\u003c/div>}\n                  \u003c/div>\n                  \u003cdiv style={{ border:'1px solid #2b2b2b', borderRadius:8, padding:'8px 10px', background:'#141414' }}>\n                    \u003cdiv style={{ fontWeight:800, marginBottom:6 }}>½× Resist\u003c/div>\n                    {resolved.weakness.x0_5.length ? (\n                      \u003cdiv style={{ display:'flex', gap:6, flexWrap:'wrap' }}>\n                        {resolved.weakness.x0_5.map(t => \u003cTypePill key={`x05-${t}`} t={t} compact />)}\n                      \u003c/div>\n                    ) : \u003cdiv className=\"label-muted\">None\u003c/div>}\n                  \u003c/div>\n                  \u003cdiv style={{ border:'1px solid #2b2b2b', borderRadius:8, padding:'8px 10px', background:'#141414' }}>\n                    \u003cdiv style={{ fontWeight:800, marginBottom:6 }}>¼× Resist\u003c/div>\n                    {resolved.weakness.x0_25.length ? (\n                      \u003cdiv style={{ display:'flex', gap:6, flexWrap:'wrap' }}>\n                        {resolved.weakness.x0_25.map(t => \u003cTypePill key={`x025-${t}`} t={t} compact />)}\n                      \u003c/div>\n                    ) : \u003cdiv className=\"label-muted\">None\u003c/div>}\n                  \u003c/div>\n                  \u003cdiv style={{ border:'1px solid #2b2b2b', borderRadius:8, padding:'8px 10px', background:'#141414' }}>\n                    \u003cdiv style={{ fontWeight:800, marginBottom:6 }}>0× Immune\u003c/div>\n                    {resolved.weakness.x0.length ? (\n                      \u003cdiv style={{ display:'flex', gap:6, flexWrap:'wrap' }}>\n                        {resolved.weakness.x0.map(t => \u003cTypePill key={`x0-${t}`} t={t} compact />)}\n                      \u003c/div>\n                    ) : \u003cdiv className=\"label-muted\">None\u003c/div>}\n                  \u003c/div>\n                \u003c/div>\n              \u003c/div>\n            \u003c/div>\n\n            {/* Right: Evolution + Locations */}\n            \u003cdiv style={styles.card}>\n             {extras?.evolutions?.length > 0 && (\n                \u003cdiv style={{ marginBottom:16 }}>\n                  \u003cdiv className=\"label-muted\" style={{ fontWeight:700, marginBottom:6 }}>Evolution\u003c/div>\n                  \u003cEvolutionChart paths={extras.evolutions} onSelect={(m) => { setSelected(m); setMode('pokemon'); setQuery(''); }} />\n                \u003c/div>\n              )}\n              \u003cdiv className=\"label-muted\" style={{ fontWeight:700, marginBottom:6 }}>Locations\u003c/div>\n              {byRegion.length === 0 && (\u003cdiv className=\"label-muted\">No wild locations found.\u003c/div>)}\n              {byRegion.map(([reg, list]) => (\n                \u003cdiv key={reg} style={{ marginBottom:12 }}>\n                  \u003cdiv style={{ fontWeight:800, marginBottom:6 }}>{reg}\u003c/div>\n                  \u003cdiv style={{ display:'grid', gap:8 }}>\n                    {list.map((loc, i) => (\n                      \u003cdiv key={i} style={{ border:'1px solid #262626', borderRadius:10, padding:'8px 10px', background:'#141414' }}>\n                        \u003cdiv style={{ fontWeight:700 }}>{loc.map}\u003c/div>\n                        \u003cdiv style={{ display:'flex', gap:6, flexWrap:'wrap', marginTop:4 }}>\n                          {(Array.isArray(loc.method) ? loc.method : [loc.method])\n                            .filter(Boolean)\n                            .map((m, j) => \u003cMethodPill key={`m-${i}-${j}-${m}`} method={m} />)}\n                          {(Array.isArray(loc.rarity) ? loc.rarity : [loc.rarity])\n                            .filter(Boolean)\n                            .map((r, j) => \u003cRarityPill key={`r-${i}-${j}-${r}`} rarity={r} />)}\n                        \u003c/div>\n                      \u003c/div>\n                    ))}\n                  \u003c/div>\n                \u003c/div>\n              ))}\n              {MOVE_METHODS.some(m => (resolved.moves?.[m.key] || []).length) && (\n                \u003c>\n                  \u003cdiv className=\"label-muted\" style={{ fontWeight:700, margin:'16px 0 6px' }}>Moveset\u003c/div>\n                  \u003cdiv style={{ display:'grid', gridTemplateColumns:'repeat(auto-fit, minmax(160px, 1fr))', gap:8 }}>\n                    {MOVE_METHODS.map(m => (\n                      \u003cdiv key={m.key} style={{ border:'1px solid #262626', borderRadius:8, padding:'8px 10px', background:'#141414' }}>\n                        \u003cdiv style={{ fontWeight:700, marginBottom:4 }}>{m.label}\u003c/div>\n                        {(resolved.moves[m.key] || []).length ? (\n                          \u003cdiv style={{ display:'flex', flexDirection:'column', gap:4, fontSize:13 }}>\n                            {resolved.moves[m.key].map((mv, idx) => (\n                              m.key === 'lv'\n                                ? \u003cdiv key={idx}>{`Lv ${mv.level}: ${mv.move}`}\u003c/div>\n                                : \u003cdiv key={idx}>{mv}\u003c/div>\n                            ))}\n                          \u003c/div>\n                        ) : (\n                          \u003cdiv className=\"label-muted\">None\u003c/div>\n                        )}\n                      \u003c/div>\n                    ))}\n                  \u003c/div>\n                \u003c/>\n              )}\n            \u003c/div>\n          \u003c/div>\n        )}\n      \u003c/div>\n\n      {/* Fixed version badge */}\n      \u003cVersionBadge />\n    \u003c/>\n  );\n}\n\nexport default App;\n","loc":{"line":1278,"column":120,"index":48548}}
              try {
                const { ErrorOverlay } = await import("/@vite/client")
                document.body.appendChild(new ErrorOverlay(error))
              } catch {
                const h = (tag, text) => {
                  const el = document.createElement(tag)
                  el.textContent = text
                  return el
                }
                document.body.appendChild(h('h1', 'Internal Server Error'))
                document.body.appendChild(h('h2', error.message))
                document.body.appendChild(h('pre', error.stack))
                document.body.appendChild(h('p', '(Error overlay failed to load)'))
              }
            </script>
          </head>
          <body>
          </body>
        </html>
      